<h1>Jetpack Compose </h1>

Современный декларативный UI-фреймворк от Google для Android. Позволяет быстро и удобно создавать адаптивные интерфейсы, минимизируя количество шаблонного кода.<br>
Почему не XML: XML-верстка устарела, требует больше кода и сложнее поддерживается. Compose проще для реактивного UI и лучше интегрируется с Kotlin.


<h1>Material3 </h1>

Для стилизации приложения по современным гайдлайнам Material Design 3.<br>
Почему не Material2: Material3 — актуальный стандарт, поддерживает новые компоненты и темы, лучше подходит для новых проектов.


<h1>Retrofit </h1>

Для удобной работы с REST API (randomuser.me). Позволяет легко описывать HTTP-запросы через интерфейсы.<br>
Почему не OkHttp напрямую: Retrofit — надстройка над OkHttp, упрощает работу с API, поддерживает автоматическую сериализацию/десериализацию.<br>
Почему не Ktor/Volley: Retrofit — стандарт де-факто для Android, лучше поддержка, больше примеров, проще интеграция с Gson.


<h1>Kotlin Coroutines </h1>

Для асинхронной работы с сетью и потоками без коллбеков, удобное управление жизненным циклом.<br>
Почему не RxJava/Thread: Coroutines проще, лаконичнее, лучше интегрируются с современным Android и Compose, меньше кода и ошибок.


<h1>Coil </h1>

Для загрузки и отображения изображений из интернета в Compose.<br>
Почему не Glide/Picasso: Coil написан на Kotlin, оптимизирован для Compose, проще интеграция, меньше зависимостей, современный API.


<h1>Navigation Compose </h1>

Для навигации между экранами в Compose-приложении.<br>
Почему не Activity/Fragment Navigation: navigation-compose — нативное решение для Compose, не требует фрагментов, проще и безопаснее.


<h1>ViewModel + Lifecycle </h1>

Для хранения состояния и бизнес-логики, переживающей повороты экрана и пересоздание UI.<br>
Почему не обычные классы: ViewModel интегрируется с жизненным циклом, предотвращает утечки памяти, стандарт для архитектуры MVVM.

<h1>Room </h1>

Room используется для локального хранения и кэширования данных пользователей в базе данных на устройстве.<br>

Почему не SQLite напрямую:<br>
Room предоставляет compile-time проверки, удобные DAO-интерфейсы, миграции и интеграцию с Kotlin-корутинами.<br>

Почему не аналоги:<br>
Realm, ObjectBox — сторонние решения, не всегда поддерживают все Android-фичи, могут быть тяжелее для простых задач.<br>
SQLiteOpenHelper — низкоуровневый, больше ручной работы и ошибок.
